# Oracle Certified Java Programmer, Gold SE 11 認定資格試験ポイント解説セミナー

## 1. Java の基礎
- final クラスの作成と使用
- 内部クラス、ネストクラス、無名クラスの使用
- 列挙型の使用

## 2. 例外処理とアサーション
- try-with-resources 文の使用
- カスタム例外クラスの作成と使用
- アサーションの使用

## 3. Java インタフェース
- デフォルト・メソッドの使用
- プライベート・メソッドの使用

## 4. コレクションとジェネリクス
- ラッパークラスとオートボクシング、オートアンボクシング
- ダイヤモンド演算子と総称型のワイルドカード
- コレクションフレームワークと主要なコレクション API
- Comparator インタフェースと Comparable インタフェース
- コレクションの便利なメソッドの使用

## 5. 関数型インタフェースとラムダ式
- 関数型インタフェースの定義と使用
- ラムダ式の引数リストと Local Variable Types

## 6. Java Stream API
- Stream API とパイプライン処理
- ラムダ式とメソッド参照

## 7. 組み込み関数型インタフェース
- java.util.function パッケージのインタフェース
- Predicate、Consumer、Function、Supplier インタフェースの使用
- 関数型インタフェースのバリエーション (特殊化された関数型インタフェース)

## 8. Stream API でのラムダ操作
- map、peek、flatMap メソッドを使用したストリームの操作
- findFirst、findAny、anyMatch、allMatch、noneMatch メソッドを使用したストリーム・データの検索
- Optional クラスの使用
- ストリームに対する count、max、min、average、sum を使用した演算
- ラムダ式を使用したストリーム・データのソート
- Collectors クラスによる終端操作 (groupingBy、partitionBy メソッドを含む)

## 9. モジュール型アプリケーションへの移行
- Java SE 8 以前のモジュール非対応のアプリケーションの Java SE 11 モジュール型アプリケーションへの移行 (トップダウン移行とボトムアップ移行)
- クラスパスとモジュールパスに対するアプリケーションの実行
- jdepsを使用した依存関係の調査

## 10.モジュール型アプリケーションのサービス
- サービスを利用するためのモジュール宣言（ディレクティブなど）
- サービス・タイプの設計とServiceLoaderの使用
- インターフェースと抽象クラス

## 11.並列処理
- Runnnable、Callableを使用したスレッドの作成とExecutorServiceを使用したタスクの並列実行
- java.util.concurrentパッケージの使用(CopyOnWriteArrayc、CyclicBarrier）
- スレッド・セーフなコードの記述
- デッドロック、ライブロックなどマルチ・スレッドにおける問題

## 12.並列ストリーム
- 並列ストリームの使用
- リダクション操作の実装

## 13. ファイル I/O (ストリームと NIO.2)
- 標準入力と Console クラスを使用したデータの読み書き
- I/O Stream クラスを使用したファイルの読み書き
- オブジェクトの読み書きとシリアライゼーション
- Path インタフェースを使用したファイルやディレクトリへのアクセス
- Files クラスを使用したファイルやディレクトリの操作
- NIO.2 と Stream API

## 14. Java SE アプリケーションにおけるセキュアコーディング
- DoS の防止
- 機密情報の保護
- データ整合性ガイドラインの実装 (入力値検証とデータの無害化)
- 外部からのコードに対する攻撃の防止 (継承の制限、可変データの保護など)
- センシティブなオブジェクトの扱い
- セキュアなシリアライゼーション処理

## 15. JDBC
- JDBC URL と DriverManager を使用したデータベースへの接続
- PreparedStatement を使用したデータベースに対する CRUD 操作
- PreparedStatement と CallabaleStatement の使用

## 16. ローカライゼーション
- Locale クラスの使用
- リソース・バンドルの使用
- メッセージ、日付、数値のフォーマット

## 17. アノテーション
- アノテーションの使用目的
- クラスとメソッドへのアノテーションの適用
- よく使用される Java アノテーション
- カスタムアノテーションの実装


## 全体傾向
- ModuleSystem
- セキュアコーディング
- シリアライゼーション、ジェネリクス（ワイルドカード）、JDBC:CRUD操作＆CallableStatement
- ラムダ式＆StreamAPI
- 出題されない（Date and Time API（コードには含まれる）)、Fork/Joinフレームワーク、デザインパターン


## 1. Java の基礎
- final クラスの作成と使用
- 内部クラス、ネストクラス、無名クラスの使用
- 列挙型の使用


### 内部クラス
```Java
//内部クラスのインスタンス化
Inner inner = new Outer().new Inner();

//静的クラス（staticな内部クラス）
InnerStatic inner = new OuterStatic.InnerStatic();
```

### 無名クラス
- 明示的なコンストラクタはもたない
- extends節やimplements節はつかえない
- メソッドのオーバーライドはOK

### enumの宣言
- enumは外部からインスタンス化できない（定数として扱える）
- switch文で使用可能（caseは定数で指定）
- ==演算子で比較可能
- enumのメソッド（name(),valueOf(),values()）
- enumに固有の値を持たせる方法
```Java
enum Color implements Serializable{
  R(255),G(204),B(0);
  int code;
  private Color(int code){
    this.code = code;
  }
  public int getCode(){
    return code;
  }
}
```

## 2. 例外処理とアサーション
- try-with-resources 文の使用
- カスタム例外クラスの作成と使用
- アサーションの使用


> java.io.Closeable インタフェース (AutoCloseable のサブタイプ)を実装する場合、
> オーバーライドするメソッドは
> ```java
> public void close() throws IOException { }
> ```

try-with-resources (Java SE 7 〜)
- try 句で宣言したリソースは自動でクローズされる
  - リソースは AutoCloseable である必要がある（I/O ストリーム, Stream API, JDBC API (Connection, Statement)）
  - リソースは final な変数 (実質的 final ) も指定可能 (Java SE 9 〜)
- リソースをクローズするタイミング
  - finally 句の処理の前
  - 複数リソースの場合はオープンしたときと逆順でクローズ

point
> Point:
> 実質的 final で思い出したいもの
> - try-with-resources (Java SE 9)
> - 無名クラス (Java SE 8)
> - ラムダ式 (Java SE 8)
> これらのコードからアクセス可能な変数は実質的final である必要がある。(実質的 final でなければコンパイルエラーになる)

### おさらい：アサーション
- 処理中で成立するべき条件を検証し条件違反を自動で検知する仕組み
- アサーションの構文
- ```java
- assert exp1;  ※exp1...検証されるべき条件、exp2...検証エラー時のメッセージ（AssertionErrorのコンストラクタ引数）
- assert exp1:exp2;
- ```
- アサーションの有効化（デフォルトは-da）
- ```java
- $ java -ea Test
- ```

## 3.Java インターフェース
- デフォルト・メソッドの使用
- プライベート・メソッドの使用

### おさらい：インターフェース
- staticメソッド
  - オーバーライド不可（継承されない）
- デフォルトメソッド
  - default キーワードを持つ実装メソッド
- プライベートメソッド（デフォルトメソッドから呼び出す）

## 4.コレクションとジェネリクス
> Point:
> オートボクシング/アンボクシングは基本データ型と対応するラッパークラスとの間で行われる。
> null をオートアンボクシングすると NPE になるので注意！


- トップレベルのパラメータ型にワイルドカード型（<?>）は指定できない（new ArrayList<List<?>>はOK）
- 左辺にはダイアモンド演算子は使えない
- ラムダ式でインスタンス化するオブジェクトは明示的な方指定が必要（＝右辺にvarは使えない）

### おさらい：コレクション
Point: 
Java のコレクションは非変なので List<Object> とList<Integer> には親子関係がないものとみなす。(配列の場合は共変なので代入可)
つまり、

```java
List<Integer> li = Arrays.asList(1, 2);
List<Object> lo = li; // NG
```

  となるが、総称型パラメータにワイルドカード型を使うことで制約を変更可能 

```java
Lust<?> lw = li; // OK
```

#### ジェネリクス
- ワイルドカード型 <?> … 総称型パラメータの変性を変更する仕組み
- ? … 非境界ワイルドカード型 (型が不明 … なので get した要素の型は Object)
- ? extends T … 上限境界ワイルドカード型 (少なくとも T のサブクラス: 共変)
- ? super T … 下限境界ワイルドカード型 (少なくとも T のスーパークラス: 反変)
- 読み込みには上限境界ワイルドカード型、書き込みには下限境界ワイルドカード型を使うのが一般的
  
コレクションの便利なメソッド (Java SE 9)
- コレクションのファクトリーメソッド of
- List, Set, Map に対して提供される
- 生成されるオブジェクトは不変 (Immutable Collection) … 追加、削除、変更不可
- Arrays.asList は固定サイズの List を返すので変更は可能

```java
List<Integer> list = new ArrayList<>(List.of(1,2,3,4,5,6,7,8,9));
```

## 11.並列処理
- Runnable、Callable を使用したスレッドの作成と ExecutorService を使用したタスクの並列実行
- java.util.concurrent パッケージの使用 (CopyOnWriteArrayList、CyclicBarrier)
-  スレッド・セーフなコードの記述
-  デッドロック、ライブロックなどマルチ・スレッドにおける問題
  
[ライフサイクル](https://github.com/miyawakiStudyJava/oracle_java/blob/main/%E3%82%B9%E3%83%AC%E3%83%83%E3%83%89%E3%81%AE%E3%83%A9%E3%82%A4%E3%83%95%E3%82%B5%E3%82%A4%E3%82%AF%E3%83%AB.png)
